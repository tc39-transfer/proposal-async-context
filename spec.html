<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<pre class="metadata">
title: AsyncContext
stage: 1
contributors: Chengzhong Wu, Justin Ridgewell
</pre>

<emu-clause id="sec-ecmascript-data-types-and-values">
  <h1>ECMAScript Data Types and Values</h1>

  <emu-clause id="sec-ecmascript-specification-types">
    <h1>ECMAScript Specification Types</h1>

    <ins class="block">
    <emu-clause id="sec-asynccontext-mapping-record-specification-type">
      <h1>The Async Context Mapping Record Specification Type</h1>
      <p>The <dfn variants="Async Context Mapping Records">Async Context Mapping Record</dfn> type is used to represent an AsyncContext.Variable value mapping in the surrounding Agent's [[AsyncContextMapping]].</p>
      <p>An Async Context Mapping Record's fields are defined by <emu-xref href="#table-asynccontext-mapping-record-fields"></emu-xref>.</p>

      <emu-table id="table-asynccontext-mapping-record-fields" caption="Async Context Mapping Record Fields">
        <table>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              [[AsyncContextKey]]
            </td>
            <td>
              an AsyncContext.Variable instance
            </td>
            <td>
              The AsyncContext.Variable instance as the key in the mapping.
            </td>
          </tr>
          <tr>
            <td>
              [[AsyncContextValue]]
            </td>
            <td>
              an ECMAScript language value
            </td>
            <td>
              The value of the AsyncContext.Variable instance in the mapping.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
    </ins>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-executable-code-and-execution-contexts">
  <h1>Executable Code and Execution Contexts</h1>

  <emu-clause id="sec-agents">
    <h1>Agents</h1>
    <p>This proposal adds a new field to the Agent Record as the following table:</p>
    <emu-table id="table-agent-record" caption="Agent Record Fields">
      <table>
        <tr>
          <th>Field Name</th>
          <th>Value</th>
          <th>Meaning</th>
        </tr>
        <tr>
          <td>[[LittleEndian]]</td>
          <td>a Boolean</td>
          <td>The default value computed for the <em>isLittleEndian</em> parameter when it is needed by the algorithms GetValueFromBuffer and SetValueInBuffer. The choice is implementation-defined and should be the alternative that is most efficient for the implementation. Once the value has been observed it cannot change.</td>
        </tr>
        <tr>
          <td>[[CanBlock]]</td>
          <td>a Boolean</td>
          <td>Determines whether the agent can block or not.</td>
        </tr>
        <tr>
          <td>[[Signifier]]</td>
          <td>an agent signifier</td>
          <td>Uniquely identifies the agent within its agent cluster.</td>
        </tr>
        <tr>
          <td>[[IsLockFree1]]</td>
          <td>a Boolean</td>
          <td>*true* if atomic operations on one-<emu-not-ref>byte values</emu-not-ref> are lock-free, *false* otherwise.</td>
        </tr>
        <tr>
          <td>[[IsLockFree2]]</td>
          <td>a Boolean</td>
          <td>*true* if atomic operations on two-<emu-not-ref>byte values</emu-not-ref> are lock-free, *false* otherwise.</td>
        </tr>
        <tr>
          <td>[[IsLockFree8]]</td>
          <td>a Boolean</td>
          <td>*true* if atomic operations on eight-<emu-not-ref>byte values</emu-not-ref> are lock-free, *false* otherwise.</td>
        </tr>
        <tr>
          <td>[[CandidateExecution]]</td>
          <td>a candidate execution Record</td>
          <td>See the memory model.</td>
        </tr>
        <tr>
          <td>[[KeptAlive]]</td>
          <td>a List of Objects</td>
          <td>Initially a new empty List, representing the list of objects to be kept alive until the end of the current Job</td>
        </tr>
        <tr>
          <td>
            <ins>[[AsyncContextMapping]]</ins>
          </td>
          <td>
            <ins>a List of Async Context Mapping Records</ins>
          </td>
          <td>
            <ins>A map from the AsyncContext.Variable instances to the saved ECMAScript language value. Every Record in the List contains a unique [[AsyncContextKey]]. The map is initially empty.</ins>
          </td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>

  <emu-clause id="sec-jobs">
    <h1>Jobs and Host Operations to Enqueue Jobs</h1>

    <emu-clause id="sec-jobcallback-records">
      <h1>JobCallback Records</h1>
      <p>This proposal adds a new field to the JobCallback Record as the following table:</p>
      <emu-table id="table-jobcallback-records" caption="JobCallback Record Fields">
        <table>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              [[Callback]]
            </td>
            <td>
              a function object
            </td>
            <td>
              The function to invoke when the Job is invoked.
            </td>
          </tr>
          <tr>
            <td>
              <ins>[[AsyncContextSnapshot]]</ins>
            </td>
            <td>
              <ins>a List of Async Context Mapping Records</ins>
            </td>
            <td>
              <ins>A map from the AsyncContext.Variable instances to the saved ECMAScript language value. Every Record in the List contains a unique [[AsyncContextKey]].</ins>
            </td>
          </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              anything (default value is ~empty~)
            </td>
            <td>
              Field reserved for use by hosts.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-hostmakejobcallback" type="host-defined abstract operation">
      <h1>
        HostMakeJobCallback (
          _callback_: a function object,
        ): a JobCallback Record
      </h1>
      <dl class="header">
      </dl>
      <p>An implementation of HostMakeJobCallback must conform to the following requirements:</p>
      <ul>
        <li>It must return a JobCallback Record whose [[Callback]] field is _callback_,</li>
        <li><ins>It must return a JobCallback Record whose [[AsyncContextSnapshot]] field is the result of performing AsyncContextSnapshot().</ins></li>
      </ul>
      <p>The default implementation of HostMakeJobCallback performs the following steps when called:</p>
      <emu-alg>
        1. <del>Return the JobCallback Record { [[Callback]]: _callback_, [[HostDefined]]: ~empty~ }.</del>
        1. <ins>Let _snapshotMapping_ be AsyncContextSnapshot().</ins>
        1. <ins>Return the JobCallback Record { [[Callback]]: _callback_, [[AsyncContextSnapshot]]: _snapshotMapping_, [[HostDefined]]: ~empty~ }.</ins>
      </emu-alg>
      <p>ECMAScript hosts that are not web browsers must use the default implementation of HostMakeJobCallback.</p>
      <emu-note>
        <p>HostMakeJobCallback snapshots the current AsyncContext global state. HostCallJobCallback restores the snapshot.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-hostcalljobcallback" type="host-defined abstract operation">
      <h1>
        HostCallJobCallback (
          _jobCallback_: a JobCallback Record,
          _V_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): either a normal completion containing an ECMAScript language value or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <p>An implementation of HostCallJobCallback must conform to the following requirements:</p>
      <ul>
        <li><ins>It must perform AsyncContextSwap(_jobCallback_.[[AsyncContextSnapshot]]) before the call,</ins></li>
        <li>It must perform and return the result of Call(_jobCallback_.[[Callback]], _V_, _argumentsList_),</li>
        <li><ins>It must perform AsyncContextSwap after the call, with the result of the earlier AsyncContextSwap operation.</ins></li>
      </ul>
      <p>The default implementation of HostCallJobCallback performs the following steps when called:</p>
      <emu-alg>
        1. Assert: IsCallable(_jobCallback_.[[Callback]]) is *true*.
        1. <del>Return ? Call(_jobCallback_.[[Callback]], _V_, _argumentsList_).</del>
        1. <ins>Let _previousContextMapping_ be AsyncContextSwap(_jobCallback_.[[AsyncContextSnapshot]]).</ins>
        1. <ins>Let _result_ be Completion(Call(_jobCallback_.[[Callback]], _V_, _argumentsList_)).</ins>
        1. <ins>AsyncContextSwap(_previousContextMapping_).</ins>
        1. <ins>Return _result_.</ins>
      </emu-alg>
      <p>ECMAScript hosts that are not web browsers must use the default implementation of HostCallJobCallback.</p>
      <emu-note>
        <p>HostCallJobCallback restores the snapshot saved in HostMakeJobCallback when calling the _jobCallback_.[[Callback]].</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-functions-and-classes">
  <h1>ECMAScript Language: Functions and Classes</h1>

  <emu-clause id="sec-generator-function-definitions">
    <h1>Generator Function Definitions</h1>

    <emu-clause id="sec-runtime-semantics-evaluategeneratorbody" oldids="sec-generator-function-definitions-runtime-semantics-evaluatebody" type="sdo">
      <h1>
        Runtime Semantics: EvaluateGeneratorBody (
          _functionObject_: a function object,
          _argumentsList_: a List of ECMAScript language values,
        ): a throw completion or a return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>GeneratorBody : FunctionBody</emu-grammar>
      <emu-alg>
        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
        1. Let _G_ be ? OrdinaryCreateFromConstructor(_functionObject_, *"%GeneratorFunction.prototype.prototype%"*, « [[GeneratorState]], [[GeneratorContext]], <ins>[[GeneratorAsyncContextMapping]],</ins> [[GeneratorBrand]] »).
        1. Set _G_.[[GeneratorBrand]] to ~empty~.
        1. Perform GeneratorStart(_G_, |FunctionBody|).
        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _G_, [[Target]]: ~empty~ }.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-async-generator-function-definitions">
    <h1>Async Generator Function Definitions</h1>

    <emu-clause id="sec-runtime-semantics-evaluateasyncgeneratorbody" oldids="sec-asyncgenerator-definitions-evaluatebody" type="sdo">
      <h1>
        Runtime Semantics: EvaluateAsyncGeneratorBody (
          _functionObject_: a function object,
          _argumentsList_: a List of ECMAScript language values,
        ): a throw completion or a return completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>
        AsyncGeneratorBody : FunctionBody
      </emu-grammar>
      <emu-alg>
        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
        1. Let _generator_ be ? OrdinaryCreateFromConstructor(_functionObject_, *"%AsyncGeneratorFunction.prototype.prototype%"*, « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], <ins>[[AsyncGeneratorAsyncContextMapping]],</ins> [[GeneratorBrand]] »).
        1. Set _generator_.[[GeneratorBrand]] to ~empty~.
        1. Perform AsyncGeneratorStart(_generator_, |FunctionBody|).
        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _generator_, [[Target]]: ~empty~ }.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-control-abstraction-objects">
  <h1>Control Abstraction Objects</h1>

  <emu-clause id="sec-generator-objects">
    <h1>Generator Objects</h1>

    <emu-clause id="sec-properties-of-generator-instances">
      <h1>Properties of Generator Instances</h1>
      <p>Generator instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-generator-instances"></emu-xref>.</p>
      <emu-table id="table-internal-slots-of-generator-instances" caption="Internal Slots of Generator Instances" oldids="table-56">
        <table>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Type
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[GeneratorState]]
            </td>
            <td>
              *undefined*, ~suspendedStart~, ~suspendedYield~, ~executing~, or ~completed~
            </td>
            <td>
              The current execution state of the generator.
            </td>
          </tr>
          <tr>
            <td>
              [[GeneratorContext]]
            </td>
            <td>
              an execution context
            </td>
            <td>
              The execution context that is used when executing the code of this generator.
            </td>
          </tr>
          <tr>
            <td>
              <ins>[[GeneratorAsyncContextMapping]]</ins>
            </td>
            <td>
              <ins>a List of Async Context Mapping Records</ins>
            </td>
            <td>
              <ins>The value of the agent's [[AsyncContextMapping]] to use the next time this generator is resumed.</ins>
            </td>
          </tr>
          <tr>
            <td>
              [[GeneratorBrand]]
            </td>
            <td>
              a String or ~empty~
            </td>
            <td>
              A brand used to distinguish different kinds of generators. The [[GeneratorBrand]] of generators declared by ECMAScript source text is always ~empty~.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-generator-abstract-operations">
      <h1>Generator Abstract Operations</h1>

      <emu-clause id="sec-generatorstart" type="abstract operation">
        <h1>
          GeneratorStart (
            _generator_: a Generator,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The value of _generator_.[[GeneratorState]] is *undefined*.
          1. Let _genContext_ be the running execution context.
          1. Set the Generator component of _genContext_ to _generator_.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:
            1. Let _acGenContext_ be the running execution context.
            1. Let _acGenerator_ be the Generator component of _acGenContext_.
            1. If _generatorBody_ is a Parse Node, then
              1. Let _result_ be Completion(Evaluation of _generatorBody_).
            1. Else,
              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.
              1. Let _result_ be _generatorBody_().
            1. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.
            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. Set _acGenerator_.[[GeneratorState]] to ~completed~.
            1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _acGenerator_ can be discarded at this point.
            1. If _result_.[[Type]] is ~normal~, then
              1. Let _resultValue_ be *undefined*.
            1. Else if _result_.[[Type]] is ~return~, then
              1. Let _resultValue_ be _result_.[[Value]].
            1. Else,
              1. Assert: _result_.[[Type]] is ~throw~.
              1. Return ? _result_.
            1. Return CreateIterResultObject(_resultValue_, *true*).
          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.
          1. Set _generator_.[[GeneratorContext]] to _genContext_.
          1. <ins>Set _generator_.[[GeneratorAsyncContextMapping]] to AsyncContextSnapshot().</ins>
          1. Set _generator_.[[GeneratorState]] to ~suspendedStart~.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorvalidate" type="abstract operation">
        <h1>
          GeneratorValidate (
            _generator_: an ECMAScript language value,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing one of ~suspendedStart~, ~suspendedYield~, or ~completed~, or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_generator_, [[GeneratorState]]).
          1. Perform ? RequireInternalSlot(_generator_, [[GeneratorBrand]]).
          1. If _generator_.[[GeneratorBrand]] is not _generatorBrand_, throw a *TypeError* exception.
          1. <del>Assert: _generator_ also has a [[GeneratorContext]] internal slot.</del>
          1. <ins>Assert: _generator_ also has [[GeneratorContext]] and [[GeneratorAsyncContextMapping]] internal slots.</ins>
          1. Let _state_ be _generator_.[[GeneratorState]].
          1. If _state_ is ~executing~, throw a *TypeError* exception.
          1. Return _state_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresume" type="abstract operation">
        <h1>
          GeneratorResume (
            _generator_: an ECMAScript language value,
            _value_: an ECMAScript language value or ~empty~,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).
          1. If _state_ is ~completed~, return CreateIterResultObject(*undefined*, *true*).
          1. Assert: _state_ is either ~suspendedStart~ or ~suspendedYield~.
          1. Let _genContext_ be _generator_.[[GeneratorContext]].
          1. Let _methodContext_ be the running execution context.
          1. Suspend _methodContext_.
          1. Set _generator_.[[GeneratorState]] to ~executing~.
          1. <ins>Let _asyncContextMapping_ be AsyncContextSwap(_generator_.[[GeneratorAsyncContextMapping]]).</ins>
          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.
          1. <emu-meta effects="user-code">Resume the suspended evaluation of _genContext_</emu-meta> using NormalCompletion(_value_) as the result of the operation that suspended it. Let _result_ be the value returned by the resumed computation.
          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.
          1. <ins>Assert: The result of AsyncContextSnapshot() is _generator_.[[GeneratorAsyncContextMapping]].</ins>
          1. <ins>AsyncContextSwap(_asyncContextMapping_).</ins>
          1. Return ? _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-generatorresumeabrupt" type="abstract operation">
        <h1>
          GeneratorResumeAbrupt (
            _generator_: an ECMAScript language value,
            _abruptCompletion_: a return completion or a throw completion,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).
          1. If _state_ is ~suspendedStart~, then
            1. Set _generator_.[[GeneratorState]] to ~completed~.
            1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _generator_ can be discarded at this point.
            1. Set _state_ to ~completed~.
          1. If _state_ is ~completed~, then
            1. If _abruptCompletion_.[[Type]] is ~return~, then
              1. Return CreateIterResultObject(_abruptCompletion_.[[Value]], *true*).
            1. Return ? _abruptCompletion_.
          1. Assert: _state_ is ~suspendedYield~.
          1. Let _genContext_ be _generator_.[[GeneratorContext]].
          1. Let _methodContext_ be the running execution context.
          1. Suspend _methodContext_.
          1. Set _generator_.[[GeneratorState]] to ~executing~.
          1. <ins>Let _asyncContextMapping_ be AsyncContextSwap(_generator_.[[GeneratorAsyncContextMapping]]).</ins>
          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.
          1. <emu-meta effects="user-code">Resume the suspended evaluation of _genContext_</emu-meta> using _abruptCompletion_ as the result of the operation that suspended it. Let _result_ be the Completion Record returned by the resumed computation.
          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.
          1. <ins>Assert: The result of AsyncContextSnapshot() is _generator_.[[GeneratorAsyncContextMapping]].</ins>
          1. <ins>AsyncContextSwap(_asyncContextMapping_).</ins>
          1. Return ? _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createiteratorfromclosure" type="abstract operation">
        <h1>
          CreateIteratorFromClosure (
            _closure_: an Abstract Closure with no parameters,
            _generatorBrand_: a String or ~empty~,
            _generatorPrototype_: an Object,
          ): a Generator
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. NOTE: _closure_ can contain uses of the Yield operation to yield an IteratorResult object.
          1. Let _internalSlotsList_ be « [[GeneratorState]], [[GeneratorContext]], <ins>[[GeneratorAsyncContextMapping]],</ins> [[GeneratorBrand]] ».
          1. Let _generator_ be OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).
          1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.
          1. Set _generator_.[[GeneratorState]] to *undefined*.
          1. Let _callerContext_ be the running execution context.
          1. Let _calleeContext_ be a new execution context.
          1. Set the Function of _calleeContext_ to *null*.
          1. Set the Realm of _calleeContext_ to the current Realm Record.
          1. Set the ScriptOrModule of _calleeContext_ to _callerContext_'s ScriptOrModule.
          1. If _callerContext_ is not already suspended, suspend _callerContext_.
          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.
          1. Perform GeneratorStart(_generator_, _closure_).
          1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
          1. Return _generator_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asyncgenerator-objects">
    <h1>AsyncGenerator Objects</h1>

    <emu-clause id="sec-properties-of-asyncgenerator-intances">
      <h1>Properties of AsyncGenerator Instances</h1>
      <p>AsyncGenerator instances are initially created with the internal slots described below:</p>
      <emu-table id="table-internal-slots-of-asyncgenerator-instances" caption="Internal Slots of AsyncGenerator Instances">
        <table>
          <tr>
            <th>Internal Slot</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>[[AsyncGeneratorState]]</td>
            <td>*undefined*, ~suspendedStart~, ~suspendedYield~, ~executing~, ~awaiting-return~, or ~completed~</td>
            <td>The current execution state of the async generator.</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorContext]]</td>
            <td>an execution context</td>
            <td>The execution context that is used when executing the code of this async generator.</td>
          </tr>
          <tr>
            <td>[[AsyncGeneratorQueue]]</td>
            <td>a List of AsyncGeneratorRequest Records</td>
            <td>Records which represent requests to resume the async generator. Except during state transitions, it is non-empty if and only if [[AsyncGeneratorState]] is either ~executing~ or ~awaiting-return~.</td>
          </tr>
          <tr>
            <td><ins>[[AsyncGeneratorAsyncContextMapping]]</ins></td>
            <td><ins>a List of Async Context Mapping Records</ins></td>
            <td><ins>The value of the agent's [[AsyncContextMapping]] to use the next time this generator is resumed.</ins></td>
          </tr>
          <tr>
            <td>[[GeneratorBrand]]</td>
            <td>a String or ~empty~</td>
            <td>A brand used to distinguish different kinds of async generators. The [[GeneratorBrand]] of async generators declared by ECMAScript source text is always ~empty~.</td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-asyncgenerator-abstract-operations">
      <h1>AsyncGenerator Abstract Operations</h1>

      <emu-clause id="sec-asyncgeneratorstart" type="abstract operation">
        <h1>
          AsyncGeneratorStart (
            _generator_: an AsyncGenerator,
            _generatorBody_: a |FunctionBody| Parse Node or an Abstract Closure with no parameters,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] is *undefined*.
          1. Let _genContext_ be the running execution context.
          1. Set the Generator component of _genContext_ to _generator_.
          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:
            1. Let _acGenContext_ be the running execution context.
            1. Let _acGenerator_ be the Generator component of _acGenContext_.
            1. If _generatorBody_ is a Parse Node, then
              1. Let _result_ be Completion(Evaluation of _generatorBody_).
            1. Else,
              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.
              1. Let _result_ be Completion(_generatorBody_()).
            1. Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.
            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.
            1. Set _acGenerator_.[[AsyncGeneratorState]] to ~completed~.
            1. If _result_.[[Type]] is ~normal~, set _result_ to NormalCompletion(*undefined*).
            1. If _result_.[[Type]] is ~return~, set _result_ to NormalCompletion(_result_.[[Value]]).
            1. Perform AsyncGeneratorCompleteStep(_acGenerator_, _result_, *true*).
            1. Perform AsyncGeneratorDrainQueue(_acGenerator_).
            1. Return *undefined*.
          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.
          1. Set _generator_.[[AsyncGeneratorContext]] to _genContext_.
          1. Set _generator_.[[AsyncGeneratorState]] to ~suspendedStart~.
          1. Set _generator_.[[AsyncGeneratorQueue]] to a new empty List.
          1. <ins>Set _generator_.[[AsyncGeneratorAsyncContextMapping]] to AsyncContextSnapshot().</ins>
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorvalidate" type="abstract operation">
        <h1>
          AsyncGeneratorValidate (
            _generator_: an ECMAScript language value,
            _generatorBrand_: a String or ~empty~,
          ): either a normal completion containing ~unused~ or a throw completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorContext]]).
          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorState]]).
          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorQueue]]).
          1. <ins>Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorAsyncContextMapping]]).</ins>
          1. If _generator_.[[GeneratorBrand]] is not _generatorBrand_, throw a *TypeError* exception.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asyncgeneratorresume" type="abstract operation">
        <h1>
          AsyncGeneratorResume (
            _generator_: an AsyncGenerator,
            _completion_: a Completion Record,
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: _generator_.[[AsyncGeneratorState]] is either ~suspendedStart~ or ~suspendedYield~.
          1. Let _genContext_ be _generator_.[[AsyncGeneratorContext]].
          1. Let _callerContext_ be the running execution context.
          1. Suspend _callerContext_.
          1. Set _generator_.[[AsyncGeneratorState]] to ~executing~.
          1. <ins>Let _asyncContextMapping_ be AsyncContextSwap(_generator_.[[AsyncGeneratorAsyncContextMapping]]).</ins>
          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.
          1. <emu-meta effects="user-code">Resume the suspended evaluation of _genContext_</emu-meta> using _completion_ as the result of the operation that suspended it. Let _result_ be the Completion Record returned by the resumed computation.
          1. Assert: _result_ is never an abrupt completion.
          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _callerContext_ is the currently running execution context.
          1. <ins>Assert: The result of AsyncContextSnapshot() is _generator_.[[AsyncGeneratorAsyncContextMapping]].</ins>
          1. <ins>AsyncContextSwap(_asyncContextMapping_).</ins>
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createasynciteratorfromclosure" type="abstract operation">
        <h1>
          CreateAsyncIteratorFromClosure (
            _closure_: an Abstract Closure with no parameters,
            _generatorBrand_: a String or ~empty~,
            _generatorPrototype_: an Object,
          ): an AsyncGenerator
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. NOTE: _closure_ can contain uses of the Await operation and uses of the Yield operation to yield an IteratorResult object.
          1. Let _internalSlotsList_ be « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], <ins>[[AsyncGeneratorAsyncContextMapping]],</ins> [[GeneratorBrand]] ».
          1. Let _generator_ be OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).
          1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.
          1. Set _generator_.[[AsyncGeneratorState]] to *undefined*.
          1. Let _callerContext_ be the running execution context.
          1. Let _calleeContext_ be a new execution context.
          1. Set the Function of _calleeContext_ to *null*.
          1. Set the Realm of _calleeContext_ to the current Realm Record.
          1. Set the ScriptOrModule of _calleeContext_ to _callerContext_'s ScriptOrModule.
          1. If _callerContext_ is not already suspended, suspend _callerContext_.
          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.
          1. Perform AsyncGeneratorStart(_generator_, _closure_).
          1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.
          1. Return _generator_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <ins class="block">

  <emu-clause id="sec-asynccontext-object">
    <h1>The AsyncContext Object</h1>
    <p>The AsyncContext object:</p>
    <ul>
      <li>is the intrinsic object <dfn>%AsyncContext%</dfn>.</li>
      <li>is the initial value of the *"AsyncContext"* property of the global object.</li>
      <li>is an ordinary object.</li>
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
      <li>is not a function object.</li>
      <li>does not have a [[Construct]] internal method; it cannot be used as a constructor with the `new` operator.</li>
      <li>does not have a [[Call]] internal method; it cannot be invoked as a function.</li>
    </ul>

    <emu-clause id="sec-asynccontext-abstract-operations">
      <h1>AsyncContext Abstract Operations</h1>
      <emu-clause id="sec-asynccontextsnapshot" type="abstract operation">
        <h1>
          AsyncContextSnapshot (
          ): a List of Async Context Mapping Records
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to snapshot the surrounding agent's Agent Record's [[AsyncContextMapping]].</dd>
        </dl>
        <emu-alg>
          1. Let _agentRecord_ be the surrounding agent's Agent Record.
          1. Return _agentRecord_.[[AsyncContextMapping]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynccontextswap" type="abstract operation">
        <h1>
          AsyncContextSwap (
            _snapshotMapping_: a List of Async Context Mapping Records
          ): a List of Async Context Mapping Records
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It is used to swap the surrounding agent's Agent Record's [[AsyncContextMapping]] with the _snapshotMapping_.</dd>
        </dl>
        <emu-alg>
          1. Let _agentRecord_ be the surrounding agent's Agent Record.
          1. Let _asyncContextMapping_ be _agentRecord_.[[AsyncContextMapping]].
          1. Set _agentRecord_.[[AsyncContextMapping]] to _snapshotMapping_.
          1. Return _asyncContextMapping_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-constructor-properties-of-the-asynccontext-object">
      <h1>Constructor Properties of the AsyncContext Object</h1>

      <emu-clause id="sec-asynccontext.snapshot">
        <h1>AsyncContext.Snapshot ( . . . )</h1>
        <p>See <emu-xref href="#sec-asynccontext-snapshot-objects"></emu-xref>.</p>
      </emu-clause>

      <emu-clause id="sec-asynccontext.variable">
        <h1>AsyncContext.Variable ( . . . )</h1>
        <p>See <emu-xref href="#sec-asynccontext-variable-objects"></emu-xref>.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-value-properties-of-the-asynccontext-object">
      <h1>Value Properties of the AsyncContext Object</h1>

      <emu-clause id="sec-asynccontext-@@tostringtag">
        <h1>AsyncContext [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value *"AsyncContext"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asynccontext-snapshot-objects">
    <h1>AsyncContext.Snapshot Objects</h1>

    <emu-clause id="sec-asynccontext-snapshot-constructor">
      <h1>The AsyncContext.Snapshot Constructor</h1>
      <p>The AsyncContext.Snapshot constructor:</p>
      <ul>
        <li>is <dfn>%AsyncContext.Snapshot%</dfn>.</li>
        <li>is the initial value of the *"Snapshot"* property of the %AsyncContext% object.</li>
        <li>creates and initializes a new AsyncContext.Snapshot when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified AsyncContext.Snapshot behaviour must include a `super` call to the AsyncContext.Snapshot constructor to create and initialize the subclass instance with the internal state necessary to support the `AsyncContext.Snapshot` and `AsyncContext.Snapshot.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-asynccontext-snapshot">
        <h1>AsyncContext.Snapshot ( )</h1>
        <p>This function performs the following steps when called:</p>

        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _snapshotMapping_ be AsyncContextSnapshot().
          1. Let _asyncSnapshot_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%AsyncContext.Snapshot.prototype%"*, « [[AsyncSnapshotMapping]] »).
          1. Set _asyncSnapshot_.[[AsyncSnapshotMapping]] to _snapshotMapping_.
          1. Return _asyncSnapshot_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-asynccontext-snapshot-constructor">
      <h1>Properties of the AsyncContext.Snapshot Constructor</h1>
      <p>The AsyncContext.Snapshot constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-asynccontext-snapshot.prototype">
        <h1>AsyncContext.Snapshot.prototype</h1>
        <p>The initial value of `AsyncContext.Snapshot.prototype` is the AsyncContext.Snapshot prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-asynccontext-snapshot-prototype-object">
      <h1>Properties of the AsyncContext.Snapshot Prototype Object</h1>
      <p>The <dfn>AsyncContext.Snapshot prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%AsyncContext.Snapshot.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have any of the other internal slots of AsyncContext.Snapshot instances.</li>
      </ul>

      <emu-clause id="sec-asynccontext-snapshot.prototype.constructor">
        <h1>AsyncContext.Snapshot.prototype.constructor</h1>
        <p>The initial value of `AsyncContext.Snapshot.prototype.constructor` is %AsyncContext.Snapshot%.</p>
      </emu-clause>

      <emu-clause id="sec-asynccontext-snapshot.prototype.run">
        <h1>AsyncContext.Snapshot.prototype.run ( _func_, ..._args_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _asyncSnapshot_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncSnapshot_, [[AsyncSnapshotMapping]]).
          1. Let _previousContextMapping_ be AsyncContextSwap(_asyncSnapshot_.[[AsyncSnapshotMapping]]).
          1. Let _result_ be Completion(Call(_func_, *undefined*, _args_)).
          1. AsyncContextSwap(_previousContextMapping_).
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynccontext-snapshot.prototype-@@tostringtag">
        <h1>AsyncContext.Snapshot.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value *"AsyncContext.Snapshot"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asynccontext-snapshot-instances">
      <h1>Properties of AsyncContext.Snapshot Instances</h1>
      <p>AsyncContext.Snapshot instances are ordinary objects that inherit properties from the AsyncContext.Snapshot prototype object (the intrinsic, %AsyncContext.Snapshot.prototype%). AsyncContext.Snapshot instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-asynccontext-snapshot-instances"></emu-xref>.</p>

      <emu-table id="table-internal-slots-of-asynccontext-snapshot-instances" caption="Internal Slots of AsyncContext-Snapshot Instances">
        <table>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Type
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[AsyncSnapshotMapping]]
            </td>
            <td>
              a List of Async Context Mapping Records
            </td>
            <td>
              Represents the snapshotted surrounding agent's Agent Record's [[AsyncContextMapping]] of the AsyncContext.Snapshot instance.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-asynccontext-variable-objects">
    <h1>AsyncContext.Variable Objects</h1>

    <emu-clause id="sec-asynccontext-variable-constructor">
      <h1>The AsyncContext.Variable Constructor</h1>
      <p>The AsyncContext.Variable constructor:</p>
      <ul>
        <li>is <dfn>%AsyncContext.Variable%</dfn>.</li>
        <li>is the initial value of the *"Variable"* property of the %AsyncContext% object.</li>
        <li>creates and initializes a new AsyncContext.Variable when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
        <li>may be used as the value in an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified AsyncContext.Variable behaviour must include a `super` call to the AsyncContext.Variable constructor to create and initialize the subclass instance with the internal state necessary to support the `AsyncContext.Variable.prototype` built-in methods.</li>
      </ul>

      <emu-clause id="sec-asynccontext-variable">
        <h1>AsyncContext.Variable ( _options_ )</h1>
        <p>This function performs the following steps when called:</p>

        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _nameStr_ be the empty String.
          1. Let _defaultValue_ be *undefined*.
          1. If _options_ is an Object, then
            1. Let _namePresent_ be ? HasProperty(_options_, *"name"*).
            1. If _namePresent_ is *true*, then
              1. Let _name_ be ? Get(_options_, *"name"*).
              1. Set _nameStr_ to ? ToString(_name_).
            1. Set _defaultValue_ to ? Get(_options_, *"defaultValue"*).
          1. Let _asyncVariable_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%AsyncContext.Variable.prototype%"*, « [[AsyncVariableName]], [[AsyncVariableDefaultValue]] »).
          1. Set _asyncVariable_.[[AsyncVariableName]] to _nameStr_.
          1. Set _asyncVariable_.[[AsyncVariableDefaultValue]] to _defaultValue_.
          1. Return _asyncVariable_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-asynccontext-variable-constructor">
      <h1>Properties of the AsyncContext.Variable Constructor</h1>
      <p>The AsyncContext.Variable constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-asynccontext-variable.prototype">
        <h1>AsyncContext.Variable.prototype</h1>
        <p>The initial value of `AsyncContext.Variable.prototype` is the AsyncContext.Variable prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-asynccontext-variable-prototype-object">
      <h1>Properties of the AsyncContext.Variable Prototype Object</h1>
      <p>The <dfn>AsyncContext.Variable prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%AsyncContext.Variable.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have any of the other internal slots of AsyncContext.Variable instances.</li>
      </ul>

      <emu-clause id="sec-asynccontext-variable.prototype.constructor">
        <h1>AsyncContext.Variable.prototype.constructor</h1>
        <p>The initial value of `AsyncContext.Variable.prototype.constructor` is %AsyncContext.Variable%.</p>
      </emu-clause>

      <emu-clause id="sec-asynccontext-variable.prototype.run">
        <h1>AsyncContext.Variable.prototype.run ( _value_, _func_, ..._args_ )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _asyncVariable_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncVariable_, [[AsyncVariableName]]).
          1. Let _previousContextMapping_ be AsyncContextSnapshot().
          1. Let _asyncContextMapping_ be a new empty List.
          1. For each Async Context Mapping Record _p_ of _previousContextMapping_, do
            1. If SameValueZero(_p_.[[AsyncContextKey]], _asyncVariable_) is *false*, then
              1. Let _q_ be the Async Context Mapping Record { [[AsyncContextKey]]: _p_.[[AsyncContextKey]], [[AsyncContextValue]]: _p_.[[AsyncContextValue]] }.
              1. Append _q_ to _asyncContextMapping_.
          1. Assert: _asyncContextMapping_ does not contain an Async Context Mapping Record whose [[AsyncContextKey]] is _asyncVariable_.
          1. Let _p_ be the Async Context Mapping Record { [[AsyncContextKey]]: _asyncVariable_, [[AsyncContextValue]]: _value_ }.
          1. Append _p_ to _asyncContextMapping_.
          1. AsyncContextSwap(_asyncContextMapping_).
          1. Let _result_ be Completion(Call(_func_, *undefined*, _args_)).
          1. AsyncContextSwap(_previousContextMapping_).
          1. Return _result_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynccontext-variable.prototype.name">
        <h1>get AsyncContext.Variable.prototype.name</h1>
        <p>`AsyncContext.Variable.prototype.name` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _asyncVariable_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncVariable_, [[AsyncVariableName]]).
          1. Return _asyncVariable_.[[AsyncVariableName]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynccontext-variable.prototype.get">
        <h1>AsyncContext.Variable.prototype.get ( )</h1>
        <p>This method performs the following steps when called:</p>
        <emu-alg>
          1. Let _asyncVariable_ be the *this* value.
          1. Perform ? RequireInternalSlot(_asyncVariable_, [[AsyncVariableDefaultValue]]).
          1. Let _agentRecord_ be the surrounding agent's Agent Record.
          1. Let _asyncContextMapping_ be _agentRecord_.[[AsyncContextMapping]].
          1. For each Async Context Mapping Record _p_ of _asyncContextMapping_, do
            1. If SameValueZero(_p_.[[AsyncContextKey]], _asyncVariable_) is *true*, return _p_.[[AsyncContextValue]].
          1. Return _asyncVariable_.[[AsyncVariableDefaultValue]].
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-asynccontext-variable.prototype-@@tostringtag">
        <h1>AsyncContext.Variable.prototype [ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value *"AsyncContext.Variable"*.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-asynccontext-variable-instances">
      <h1>Properties of AsyncContext.Variable Instances</h1>
      <p>AsyncContext.Variable instances are ordinary objects that inherit properties from the AsyncContext.Variable prototype object (the intrinsic, %AsyncContext.Variable.prototype%). AsyncContext.Variable instances are initially created with the internal slots described in <emu-xref href="#table-internal-slots-of-asynccontext-variable-instances"></emu-xref>.</p>

      <emu-table id="table-internal-slots-of-asynccontext-variable-instances" caption="Internal Slots of AsyncContext.Variable Instances">
        <table>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Type
            </th>
            <th>
              Description
            </th>
          </tr>
          <tr>
            <td>
              [[AsyncVariableName]]
            </td>
            <td>
              a String
            </td>
            <td>
              The name of the AsyncContext.Variable instance.
            </td>
          </tr>
          <tr>
            <td>
              [[AsyncVariableDefaultValue]]
            </td>
            <td>
              an ECMAScript language value
            </td>
            <td>
              The default value of the AsyncContext.Variable instance when no entry is found in the mapping.
            </td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>
  </emu-clause>
  </ins>
</emu-clause>
